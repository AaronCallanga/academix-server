- Create a base interface Email Service
        void sendEmail
- Create an implementation of EmailService: abstract BaseEmailServiceImpl (acts as a base impl class - abstract allows to share logic)
        @Override sendEmail
- Create domain specific interface that extends EmailService
        AuthEmailService            void sendVerificationToken      (done)
        DocumentEmailService        void sendDocumentRequestReminder
- Create the implementation of AuthEmailService and DocumentEmailService:
        AuthEmailServiceImpl extends BaseEmailServiceImpl
        DocumentEmailServiceImpl extends BaseEmailServiceImpl
        -- we extends BaseEmailServiceImpl to use the shared logic sendEmail

Other domains:
- Notification
- Logging
- Scheduling

// do cleanup refactoring
POST	/api/notifications/send-email	Send email manually
POST	/api/notifications/send-sms	Send SMS manually
GET	/api/notifications/logs	View sent logs


Send email when:
    - request expired

Scheduled Job
    - clean up of completed request (per 2 year?) (status is RELEASED) - test


    1. Create a archive_request table and archive_feedback
    2. every time you delete a request, put the feedback and request to the the archive table
    3. then delete the original request and feedback data in the request/feedback table



2. Manually delete feedback first (controlled cleanup)
If you want more control (e.g., archive feedback before deleting request):
Create a cleaning service:
java
Copy
Edit
@Transactional
public void deleteRequestAndFeedback(Long requestId) {
    feedbackRepository.deleteByDocumentRequestId(requestId);
    documentRequestRepository.deleteById(requestId);
}


